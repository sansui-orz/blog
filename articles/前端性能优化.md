# 前端性能优化总结

“少年，体验过健步如飞的感觉吗？” -- 搬砖人

## 首屏首次加载优化

为什么叫首屏首次加载优化呢，是因为首次的时候没有缓存，这时候最考验产品的优化程度，虽然加载很大程度上取决于用户的网络状态，但是显然这并不能说服老板。

### 分包加载

提到首屏加载优化，最先想到的应该还是分包加载。分包加载指的就是通过代码拆分的手段，将首屏代码资源单独分出一个代码包（js文件），当然，大部分时候还可能会拆除一个公用包用来承载一些公用库（如react.js / axios.js等）。

而分包的手段在日常工作中已经是十分常见了，不论是webpack分包，小程序分包，亦或是小游戏分包。目前都已经提供了比较成熟的解决方案。

这里简单介绍一下这几种分包方式的用法：

#### webpack分包

```javascript
const path = require('path');
const webpack = require('webpack');
const HTMLWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: {
    index: './src/index.js',
    another: './src/another-module.js'
  },
  plugins: [
    new HTMLWebpackPlugin({
      title: 'Code Splitting'
    }),
    new webpack.optimize.CommonsChunkPlugin({
      name: 'common' // 指定公共 bundle 的名称。
    })
  ],
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
};
```

代码如上，该webpack指定了两个`entry`，并且使用`CommonsChunkPlugin`插件将公用模块拆成一个独立的代码包，最终会生成`index.bundle.js`，`another.bundle.js`，`common.bundle.js`。

而在加载的时候只会加载指定的`entry`包以及公共包，如果在业务代码比较庞大的时候，将非首页的，非必要的，非常用的代码单独拆分成一个或几个包就非常的必要了。

ps: 还有一种方式是，不需要指定多个`entry`，而是使用[`import()`动态加载功能](https://www.webpackjs.com/api/module-methods/#import-)

#### 小程序(以微信小程序为例)分包

小程序内分包又可以有两种形式，第一种是常规的分包，即分为主包以及多个小包。第二种则是根据独立功能拆分出独立包。

首先是常规分包，只需要在`app.json`内设置`subpackages`字段，在打包是构建工具就会将代码按照配置打包成多个包。

注意的是配置是按照页面路径来区分分包逻辑的，那么此时如果多个子包应用了同一模块，那么该模块将会被打入主包，这样才能够被多个子包复用。

所以打包逻辑一般遵循“首页（或者几个访问量大的）页面打在主包，其他自包根据功能是否递进或耦合进行拆分”的规则。

```json
{
  "pages":[
    "pages/index",
    "pages/logs"
  ],
  "subpackages": [
    {
      "root": "packageA",
      "pages": [
        "pages/cat",
        "pages/dog"
      ]
    }, {
      "root": "packageB",
      "name": "pack2",
      "pages": [
        "pages/apple",
        "pages/banana"
      ]
    }
  ]
}
```

第二种形式是拆分独立包，这种模式一般运用在某个访问量大，独立，功能单一的页面。

比如： 某某火车票抢票小程序的分享好友加速，某某生鲜小程序的分享红包页面等。

可以注意到应用独立包的场景都是符合“访问量大，独立，功能单一”的场景，因为这些场景不依赖其他逻辑，一般仅仅是拉回流用户，引导用户进入小程序消费，所以需要做到快速响应，先让用户进来，再通过红包/折扣的诱惑引导用户进一步消费。

这时候就非常考验该页面的加载性能，一般这种场景都是用户点击分享卡片进入，目标性较差，如遇到加载时间较长很容易失去耐心直接退出。而独立包则十分完美的满足了这种场景需求。

配置方面，仅需将该分包的`independent`设为true就可以了，但是需要注意的是，该页面不要包含大的模块，否则打出来的包大了，就起不到”小而精“的作用了。且独立包与其他包是独立的，也就是说就算主包与独立包引用了同一模块，那独立报与主包都会包含该模块。

```json
{
  "pages": [
    "pages/index",
    "pages/logs"
  ],
  "subpackages": [
    {
      "root": "moduleA",
      "pages": [
        "pages/rabbit",
        "pages/squirrel"
      ]
    }, {
      "root": "moduleB",
      "pages": [
        "pages/pear",
        "pages/pineapple"
      ],
      "independent": true
    }
  ]
}
```

#### 小游戏分包(以微信小游戏 && cocos creator为例)

微信小游戏也支持分包加载的配置，配置方式跟小程序配置是一样的，只需要配置一下`game.json`的`subpackages`字段就可以了。

```json
{
  ...
  "subpackages": [
    {
      "name": "stage1",
      "root": "stage1/" // 可以指定一个目录，目录根目录下的 game.js 会作为入口文件，目录下所有资源将会统一打包
    }, {
      "name": "stage2",
      "root": "stage2.js" // 也可以指定一个 JS 文件
    }
  ]
  ...
}
```

而加载则使用[wx.loadSubpackage()](https://developers.weixin.qq.com/minigame/dev/guide/base-ability/sub-packages.html)api来触发分包的下载。

而cocos creator也在v2.4.0版本支持了分包的[配置](https://docs.cocos.com/creator/manual/zh/scripting/asset-bundle.html#%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95)，
配置的方式是在编辑内根据文件夹配置来分包。

![分包配置示例](./imgs/inspector.png)

加载则是使用[cc.assetManager.loadBundle()](https://docs.cocos.com/creator/manual/zh/scripting/asset-bundle.html#%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95)api来控制分包的加载。

很不幸的是，v2.4.0刚出不到一个月，暂时还没上手尝试，不过按照惯例，估计坑不少。

以上就是代码分包的几个场景了，往往代码分包产生的效益是立竿见影的，这也是为什么它频繁被提起的原因，首次加载的资源少了，加载速度自然就上来了。

### 服务端渲染

服务端渲染主要解决的是两个问题

1. 首屏渲染加速

2. SEO优化

服务端渲染主要是在服务端提前渲染好页面资源，然后浏览器在文档返回之后不需要等待与运行js即可立即在页面中呈现出内容，而搜索引擎也可以通过检索文档内容，提高页面被呈现的几率（客户端渲染则不行，因为文档是空的）。

但是服务端渲染会将原本由用户承担的渲染成本集中到服务器上，所以在成本与效益之间如何均衡就要看各自的考量了。

这里有一篇[react服务端渲染项目搭建](./react服务端渲染项目搭建.md), 感兴趣的可以看看。

### 图片优化

通常一个互联网项目少不了图片的出现，web最初也只是用来承载文本与图片，只是在时代发展下逐渐扩充了其功能，才形成目前五花八门的应用场景（视频/音频等）。

而归根结底，文本与图片的应用也是重中之重。众所周知，图片的质量越大，加载则越慢。应该接触过互联网的人都有经历过网络慢的时候，打开一个网页肯定是文字先出来，然后才是图片。

这是因为文本小且它是跟文档一起被加载的，而图片则是在文档被解析中或解析后才发出的请求。在本身加载就比较靠后的情况下，如果图片还大，则会出现加载很久甚至加载失败的情况，而这种状况在你看来正常，但是在用户眼中，就是优化不当或者产品bug。

由于图片优化内容比较多，所以单独拎出来作为一块，请移步[图片优化实践](./图片优化实践.md)

### 使用CDN

关于cdn的文章五花八门，没看过的赶紧百度一下。简单来说CDN就是在世界各地部署服务器，当你需要一个静态资源的时候，就可以直接从离你最近的那台服务器上获取。

比如人在北京，但是你的服务器在纽约，那你要获取个资源就得跑一个地球周长那么远（一来一回）。但是如果你把静态资源部署到北京的cdn服务器上，那就是两步路的事情，cdn就是那么牛逼。

而一般cdn服务器的地址跟业务服务器地址是分开的，这间接的帮你把资源与api的域名区分开，这样做有两个好处：

1. 请求资源不会携带cookie。（统一域名下的所有请求都会携带cookie）

2. 请求并发数增加（Chrome中同域名下最多并发6条请求，多的会排队）

所以能用cdn就用上，反正对于前端来说也就是一键部署的事儿。

### 合并散碎小文件，拆分资源域名，延迟加载大文件

前面多处地方提到浏览器有并发数限制，而一般一个网站一打开就会有十几二十条以上的请求被发出，此时就很大可能会触发请求数上限的限制了。

而如果你在页面中加载了多个大文件，那就很可能请求数被这些大文件占用从而导致其他资源请求无法发出。一般来收，”js + css + 大图“再加一些音视频，很容易就可以超过6个大文件。

这时候就需要将暂时不会立刻使用到的大文件延后加载了，前面提到的代码分包也是这个目的，比如加载大图或者音视频，完全可以放到DOMContentLoaded之后再加载，优先保证js跑起来，页面能有展示内容。

而合并散碎小文件也很好理解，比如你有三个css分别是`base.css`, `theme.css`, `page.css`。这时候合并成一个反而更好，即减少了网络请求，又不需要考虑其中某个css加载失败的异常（要死一起死）。

同理还有小图标的合并，js文件的合并等。

 **拆分资源域名** 是最后的优化手段，毕竟不可能那么多域名给你用，公司资源都是宝贵的，但是真当你把资源都合并之后还是有这么多请求，那就要认真考虑一下是否拆分域名了（这种情况我在小游戏中遇到过）。

### 特殊的优化手段（离线包与预渲染）

页面的渲染必然依赖各种资源，而如果我们可以提前加载好那些资源是不是理论上可以做到快速启动一个页面呢？

但是肯定的是，单纯借用web与浏览器的作用是无法在用户没有访问过页面之前就拥有页面的资源缓存的。

可是现在流行的 **混合开发（Hybrid App）** 却可以提供这种能力。

在原生客户端，可以为web定制一种提前获得页面资源的手段，在应用打包时内置一份前端项目代码，在webview发出请求的时候对请求进行拦截匹配，当匹配成功时则直接使用离线资源，这就是简单的 **离线包** 的概念。

要知道当你使用离线资源的速度是很快的，这能给一个web应用的体验带来极大的提升。

但是这样做也有弊端，要知道web项目一般都具备快速迭代的特性，内置到应用包里面如果页面需要更新怎么办？

这时我们就需要提供一份配置去控制我们的离线包是否过期了。

假设我们提供了一个json文件，文件内包含离线包版本号，离线资源匹配规则，离线包下载地址等信息，而当应用启动时去服务器上请求最新的离线包配置与本地配置进行对比，如果版本不一致则覆盖本地缓存，这就完美解决了离线包版本控制的问题了。

但是需要注意的是，主文档不应该被作为离线资源下发，因为当业务更改时，打包出来的js与css的hash变化只有在html文档中才有引用，所以如果html文档也使用离线包，在离线包还未更新的情况下，是无法使用修改后的web应用的，而在线请求的离线包则没有这个问题，即使没有命中离线资源，它也还是可以请求在线资源，并不影响用户的访问。

 **既然离线包已经那么强大了，还有没有进一步优化空间呢？**

离线包只是加载静态资源很快而已，但是它还需要初始化 webview的耗时，还需要加载主文档与发起请求。

这些步骤我们也可以想办法去进行优化，尽量减少这些耗时。这就涉及到另一个技术规则 -- **“预渲染”**。

预渲染指的就是当你还未在一个应用内访问web模块时，应用已经提前渲染后该web服务，只需要用户点击时调出该webview，即可立即使用。

听起来似乎很简单，但是这其中还是有几个难点。

第一，当一个混合开发项目包含多个web模块时，如何知道用户会点击哪个模块（全部模块渲染不现实，损耗太大），这就涉及到数据分析了，分析用户日常最经常使用哪个模块，以及用户目前进入路径是否有极强目的性的。对于新用户则可以通过判断来源，依靠大部分用户的选择来决定提前渲染哪个服务。

第二，如何区分预渲染时的loaded与正常渲染的loaded。这点很重要，一般的产品会在页面的加载前，加载成功后进行数据打点来验证访问漏斗等数据。如果这时候不进行区分，则这块的数据就不准确，并且一些逻辑也需要定制，比如进入页面自动播放，展示一个3s的toast等。这可以让客户端提供定制的jsBridge api来控制。

第三，对于资源的损耗，预渲染是无法保证用户会进入渲染的页面的，所以也就导致浪费了用户流量与加大了服务器压力，最后用户却并没有买单，甚至看到你的应用这么吃流量怒而删app走人。

以上这些手段都是基于有一个原生客户端给你兜底的情况（微信小程序也是差不多的策略），一般的web应用只能通过运用一些缓存的手段达到拥有缓存后大大加快访问速度。

### 最后的倔强（骨架屏或loading动画）

如果什么手段都用了，但是老板还是喜欢清掉缓存在封闭的厕所看自己的产品的话，那你也没辙。

此时你唯一要想的就是如何让老板（用户）明白，不是你的程序出bug了，是他网络不好。

做过vue/react的应该都遇到过关键js代码加载时卡住了，导致页面一片空白，这就是“你的程序出bug了“的日常套路。

而这时候给页面一个骨架屏，或者一个loading动画，提示用户现在正在加载中，而不是出现了bug，会让用户更加有耐心等待下去。

## 非首屏加载优化

### 合理利用浏览器缓存

浏览器自己就拥有一套缓存，跟前面说过的离线包很类似，它可以把静态资源缓存到内存或磁盘，下次再访问的时候直接使用缓存资源，快到飞起。

浏览器缓存有以下几种:

1. http Cache(disk Cache)

2. Memory Cache

3. Service Worker Cache

4. Push Cache

 **http Cache** 又称浏览器缓存，是根据获取到的网络资源响应头中的信息判断是否缓存的一种手段。

它又分为 **强缓存** 与 **协商缓存** ，它的说明请移步[Http缓存机制](./Http%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.md)

 **Memory Cache** 是内存缓存，一般来说浏览器最先尝试命中的就是内存缓存，因为它是直接缓存在内存中的，所以响应速度最快。

 但是在内存中的缓存在页面关闭时，该内存被释放，缓存也就没了。而且因为内存空间有限，它只会缓存一些小文件。

 **Service Worker Cache** 该部分待补充。

> Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。

 **Push Cache** Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。待补充。

合理运用这些缓存，尽量不要频繁的更新代码，因为更新代码之后hash变了，就导致之前的缓存用不了。

当然，每次更新的时候如果小功能上线的话，应该也只是单纯影响该功能的js包，其他的绝大多数缓存还是有效的。

### 懒加载

懒加载为什么会放在非首屏呢，因为首屏资源基本上只需要保证展示在一屏内的资源快速加载出来就可以了，所以我把它归类到非首屏了。

懒加载在[图片优化](./图片优化实践.md)也有简单的提到，这里来说以下它的具体实现。

一般现在的项目都是直接使用`IntersectionObserver`来实现元素大曝光与显示，真是简单有好用。(ie不兼容，但是我已经抛弃ie了)

直接上手写一个React的Image组件

```jsx
// 直接使用一个IntersectionObserver实例
const intersectionObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.intersectionRatio > 0) { // 判断是否进入检测区域（注意这里是检测区域不是可视区域）
      const targetImg = entry.target;
      if (!targetImg.src) { // 如果进入的图片元素没有src属性，则给它赋值
        const src = targetImg.getAttribute('data-src');
        if (src) {
          targetImg.src = src;
          intersectionObserver.unobserve(targetImg); // 赋值完成之后把这个已经加载资源的元素从检测列表中移除
        }
      }
    }
  });
}, {
  rootMargin: '50% 50% 50% 50%', // 定义检测区域大小，这里分别是距离屏幕四边半个屏幕，这么做的原因是因为不能进入视图才加载，会来不及，所以得提前半个屏幕加载
});

export default class Image extends Component {
  ref = React.createRef();

  componentDidMount() {
    const { current } = this.ref;
    intersectionObserver.observe(current); // 将该img加入检测
  }

  componentWillUnmount() {
    const { current } = this.ref;
    if (!current.src) {
      intersectionObserver.unobserve(current); // 如果移除时还没进入视图，则移除检测
    }
  }

  render() {
    return <img className="lazy-image" data-src={this.props.src} alt="" ref={this.ref} />;
  }
}
```

这是一个图片监听的简单实现，可以扩展以下，加个是否需要懒加载的控制，或者加class,style的控制，加一些回调函数等。

### 减少DOM交互

与DOM交互的性能损耗是很大的，所以我们应该尽量减少js与dom的交互。

### 长列表优化

很多产品都拥有长列表，比如电商，比如论坛。一般这种流式的内容都会有上拉加载的功能，而当你上拉次数足够多，你的dom数就会达到一个庞大的量。

此时你就会明显的感觉到你的页面开始变得卡顿了。这是一个前端产品的痛点。

### 利用Resource Hints进行资源的预加载

Resource Hints很好用，使用简单，兼容性好，且不会产生副作用。何乐而不为呢。

## 参考文档

[前端性能优化原理与实践](https://juejin.im/book/5b936540f265da0a9624b04b)
