### 类:
 - 默认的Public:
注意事项：当类继承并显示声明constructor方法时，需要调用super用以调用父类的构造函数，构建子类的this。而只是单纯的类生命时，由于没有父类，所以调用super将会报错。
```
// ts中，如类属性未指定修饰符的，默认为public
class Animal {
    public name: string;
}
```

 - private:
```
// 当成员呗标记城private时，它就不能在声明它的类的外部访问。
class Animal {
    private name: string;
    constructor(name: string) { this.name = name; }
}
new Animal('Cat').name; // error: 外部不能访问
```

 - project:
```
// projected修饰符与private修饰符的行为相似，但是project成员在子类中可以访问
class Animal {
    project name: string;
    constructor(name: string) { this.name = name; }
}
class Cat extends Animal {
    construcor() {
        super('cat');
    }
    sayName() {
        console.log(this.name);
    }
}
var cat = new Cat();
cat.sayName(); // cat
cat.name; // error: 不可以在外部访问
```
注意构造函数也可以用project修饰, 这意味着它只能用来做父类被调用，不能直接实例化:
```
class Animal {
    project name: string;
    project constructor(name: string) { this.name = name; }
}
class Cat extends Animal {
    construcor() {
        super('cat');
    }
    sayName() {
        console.log(this.name);
    }
}
var cat = new Cat();
var dog = new Animal('dog'); // error: Animal的构造函数只能在子类中被调用
```

 - readonly修饰符:
readyonly关键字将属性设置为只读的，并且需要在声明时或构造函数里被初始化
```
class Example {
    readonly name: string;
    readyonly city: string = '北京';
    constructor(name) { this.name = name; }
}
```

 - 参数属性:
```
class Example {
    consructor(public name: string) {}
}
var e = new Example('e');
e.name; // e
```

 - static 静态属性:
```
class E1 {
    static name: string = 'e1';
    test(): void {
        console.log(this.name); // undefined
        console.log(E1.name); // e1
    }
}

class E2 extends E1 {
    test(): void {
        console.log(this.name); // undefined
        console.log(super.name); // undefined
    }
}
var e1 = new E1();
var e2 = new E2();
e1.test();
e2.test();
```